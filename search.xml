<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2020/12/04/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
<h3 id="常用的hexo命令"><a href="#常用的hexo命令" class="headerlink" title="常用的hexo命令"></a>常用的hexo命令</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new <span class="string">&quot;postName&quot;</span> <span class="comment">#新建文章</span></span><br><span class="line">hexo new page <span class="string">&quot;pageName&quot;</span> <span class="comment">#新建页面</span></span><br><span class="line">hexo generate <span class="comment">#生成静态页面至public目录</span></span><br><span class="line">hexo server <span class="comment">#开启预览访问端口（默认端口4000，&#x27;ctrl + c&#x27;关闭server）</span></span><br><span class="line">hexo deploy <span class="comment">#部署到GitHub</span></span><br><span class="line">hexo <span class="built_in">help</span>  <span class="comment"># 查看帮助</span></span><br><span class="line">hexo version  <span class="comment">#查看Hexo的版本</span></span><br></pre></td></tr></table></figure>

<h4 id="缩写"><a href="#缩写" class="headerlink" title="缩写"></a>缩写</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo n == hexo new</span><br><span class="line">hexo g == hexo generate</span><br><span class="line">hexo s == hexo server</span><br><span class="line">hexo d == hexo deploy</span><br></pre></td></tr></table></figure>

<h4 id="组合命令"><a href="#组合命令" class="headerlink" title="组合命令"></a>组合命令</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo s -g <span class="comment">#生成并本地预览</span></span><br><span class="line">hexo d -g <span class="comment">#生成并上传</span></span><br></pre></td></tr></table></figure>

<h4 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h4><p><a href="https://juejin.cn/post/6844903887732736007">hexo在GitHub上搭建个人博客（详细教程）</a></p>
<p><a href="https://blog.csdn.net/heimu24/article/details/81210640">hexo个人博客：换了电脑怎么办</a></p>
]]></content>
  </entry>
  <entry>
    <title>ssm + springboot 跨域问题记录</title>
    <url>/2020/12/04/ssm-springboot-%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h3 id="springboot-服务端解决跨域问题"><a href="#springboot-服务端解决跨域问题" class="headerlink" title="springboot 服务端解决跨域问题"></a>springboot 服务端解决跨域问题</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.CorsRegistry;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.WebMvcConfigurer;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebMvcConfig</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addCorsMappings</span><span class="params">(CorsRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.addMapping(<span class="string">&quot;/**&quot;</span>)</span><br><span class="line">                .allowedOrigins(<span class="string">&quot;*&quot;</span>)</span><br><span class="line">                .allowedMethods(<span class="string">&quot;*&quot;</span>)</span><br><span class="line">                .allowedHeaders(<span class="string">&quot;*&quot;</span>)</span><br><span class="line">                .allowCredentials(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ssm-tomcat-解决跨域问题"><a href="#ssm-tomcat-解决跨域问题" class="headerlink" title="ssm + tomcat 解决跨域问题"></a>ssm + tomcat 解决跨域问题</h3><a id="more"></a>

<h4 id="tomcat配置"><a href="#tomcat配置" class="headerlink" title="tomcat配置"></a>tomcat配置</h4><ol>
<li>web.xml 过滤配置<br>打开tomcat安装目录的conf目录，打开web.xml文件，然后在此文件的中间位置，大概460多行附近，粘贴如下代码到此文件<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CORS<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>com.thetransactioncompany.cors.CORSFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>cors.allowOrigin<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>*<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>cors.supportedMethods<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>GET,POST,HEAD,PUT,DELETE<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>cors.supportedHeaders<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>Accept,Origin,X-Requested-With,Content-Type,Last-Modified<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>cors.exposedHeaders<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>Set-Cookie<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>cors.supportsCredentials<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CORS<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span> </span><br></pre></td></tr></table></figure></li>
<li>lib放入jar包:cors-filter-1.7.jar和java-property-utils-1.9.1.jar</li>
</ol>
<ol start="3">
<li>打开谷歌浏览器快捷方式的属性面板，然后在【目标】这个属性之后跟下面的代码：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">--args --disable-web-security --user-data-dir</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="idea-tomcat-配置项目注意点"><a href="#idea-tomcat-配置项目注意点" class="headerlink" title="idea tomcat 配置项目注意点"></a>idea tomcat 配置项目注意点</h3><ol>
<li><p><img src="/2020/12/04/ssm-springboot-%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/0.png" alt="Lena"></p>
<p>【Run/Debug Configurations】 -&gt; Deploment -&gt; Application context: 设置为 / (如果项目名字为空的话)</p>
</li>
</ol>
]]></content>
      <categories>
        <category>java web</category>
      </categories>
      <tags>
        <tag>java web</tag>
      </tags>
  </entry>
  <entry>
    <title>网络IO</title>
    <url>/2021/03/15/%E7%BD%91%E7%BB%9CIO/</url>
    <content><![CDATA[<p><img src="/2021/03/15/%E7%BD%91%E7%BB%9CIO/0.jpg" alt="Linux网络编程"></p>
<h3 id="网络IO发展大致分为如下几个阶段"><a href="#网络IO发展大致分为如下几个阶段" class="headerlink" title="网络IO发展大致分为如下几个阶段"></a>网络IO发展大致分为如下几个阶段</h3><ul>
<li>阻塞IO (<strong>BIO</strong>)</li>
<li>非阻塞IO (<strong>NIO</strong>)</li>
<li>IO多路复用 （<strong>select/poll/epoll</strong>）</li>
<li>异步IO (<strong>AIO</strong>)</li>
<li>—信号驱动</li>
</ul>
<p><img src="/2021/03/15/%E7%BD%91%E7%BB%9CIO/1.jpg" alt="网络IO的演变过程"></p>
<h4 id="网络的两个阶段"><a href="#网络的两个阶段" class="headerlink" title="网络的两个阶段"></a>网络的两个阶段</h4><ul>
<li><strong>第一阶段：硬件接口到内核态</strong></li>
<li><strong>第二阶段：内核态到用户态</strong></li>
</ul>
<a id="more"></a>

<p>​    对于两台计算机而言，要进行网络通信，其数据都是先从应用程序传递到传输层(TCP/UDP)到达内核态，然后再到网络层、数据链路层、物理层，接着数据传递到硬件网卡，最后通过网络传输介质传递到对端机器的网卡，然后再一步一步数据从网卡传递到内核态，最后再拷贝到用户态。</p>
<p><img src="/2021/03/15/%E7%BD%91%E7%BB%9CIO/2.jpg" alt="网络IO的两个阶段"></p>
<h4 id="阻塞-IO-和非阻塞-IO-的区别"><a href="#阻塞-IO-和非阻塞-IO-的区别" class="headerlink" title="阻塞 IO 和非阻塞 IO 的区别"></a><strong>阻塞 IO 和非阻塞 IO 的区别</strong></h4><p>​    把从<strong>硬件到内核态</strong>这一阶段，是否发生阻塞等待，可以将网络分为<strong>阻塞 IO</strong>和<strong>非阻塞 IO</strong>。如果用户发起了读写请求，但内核态数据还未准备就绪，该阶段不会阻塞用户操作，内核立马返回，则称为非阻塞 IO。如果该阶段一直阻塞用户操作。直到内核态数据准备就绪，才返回。这种方式称为阻塞 IO。</p>
<p>​    因此，区分阻塞 IO 和非阻塞 IO 主要看第一阶段是否阻塞用户操作。</p>
<h4 id="同步-IO-和异步-IO-的区别"><a href="#同步-IO-和异步-IO-的区别" class="headerlink" title="同步 IO 和异步 IO 的区别"></a><strong>同步 IO 和异步 IO 的区别</strong></h4><p>​    数据的传递需要两个阶段，在此处只要任何一个阶段会阻塞用户请求，都将其称为同步 IO，两个阶段都不阻塞，则称为异步 IO。</p>
<p>​    在目前所有的操作系统中，linux 中的 epoll、mac 的 kqueue 都属于同步 IO，因为其在第二阶段(数据从内核态到用户态)都会发生拷贝阻塞。 而只有 windows 中的 <strong>IOCP</strong> 才真正属于异步 IO，即 AIO。</p>
<h3 id="阻塞-IO"><a href="#阻塞-IO" class="headerlink" title="阻塞 IO"></a><strong>阻塞 IO</strong></h3><ul>
<li>阻塞 IO 主要指的是第一阶段(硬件网卡到内核态)。</li>
</ul>
<h4 id="阻塞IO概念"><a href="#阻塞IO概念" class="headerlink" title="阻塞IO概念"></a>阻塞IO概念</h4><ul>
<li>阻塞 IO，顾名思义当用户发生了系统调用后，如果数据未从网卡到达内核态，内核态数据未准备好，此时会一直阻塞。直到数据就绪，然后从内核态拷贝到用户态再返回</li>
</ul>
<h4 id="阻塞-IO-的过程"><a href="#阻塞-IO-的过程" class="headerlink" title="阻塞 IO 的过程"></a><strong>阻塞 IO 的过程</strong></h4><p><img src="/2021/03/15/%E7%BD%91%E7%BB%9CIO/3.jpg" alt="阻塞IO过程"></p>
<h4 id="阻塞-IO-的缺点"><a href="#阻塞-IO-的缺点" class="headerlink" title="阻塞 IO 的缺点"></a><strong>阻塞 IO 的缺点</strong></h4><p>在一般使用阻塞 IO 时，都需要配置多线程来使用，最常见的模型是<strong>阻塞 IO+多线程</strong>，每个连接一个单独的线程进行处理。</p>
<p><strong>我们知道，一般一个程序可以开辟的线程是优先的，而且开辟线程的开销也是比较大的。也正是这种方式，会导致一个应用程序可以处理的客户端请求受限。面对百万连接的情况，是无法处理。</strong></p>
<h3 id="非阻塞-IO"><a href="#非阻塞-IO" class="headerlink" title="非阻塞 IO"></a>非阻塞 IO</h3><ul>
<li>非阻塞 IO 是为了解决前面提到的阻塞 IO 的缺陷而引出的</li>
</ul>
<h4 id="非阻塞-IO-的概念"><a href="#非阻塞-IO-的概念" class="headerlink" title="非阻塞 IO 的概念"></a><strong>非阻塞 IO 的概念</strong></h4><p>​        非阻塞 IO：见名知意，就是在第一阶段(网卡-内核态)数据未到达时不等待，然后直接返回。因此非阻塞 IO 需要不断的用户发起请求，询问内核数据好了没，好了没。</p>
<h4 id="非阻塞-IO-的过程"><a href="#非阻塞-IO-的过程" class="headerlink" title="非阻塞 IO 的过程"></a>非阻塞 IO 的过程</h4><p><img src="/2021/03/15/%E7%BD%91%E7%BB%9CIO/4.jpg" alt="非阻塞IO过程"></p>
<h4 id="非阻塞-IO-的优点"><a href="#非阻塞-IO-的优点" class="headerlink" title="非阻塞 IO 的优点"></a><strong>非阻塞 IO 的优点</strong></h4><ul>
<li>非阻塞 IO 解决了阻塞 IO<strong>每个连接一个线程处理的问题</strong>，所以其最大的优点就是 <strong>一个线程可以处理多个连接</strong>，这也是其非阻塞决定的。</li>
</ul>
<h4 id="非阻塞-IO-的缺点"><a href="#非阻塞-IO-的缺点" class="headerlink" title="非阻塞 IO 的缺点"></a><strong>非阻塞 IO 的缺点</strong></h4><ul>
<li>需要用户多次发起系统调用。<strong>频繁的系统调用</strong>是比较消耗系统资源的。</li>
<li>解决问题：<strong>保留非阻塞 IO 的优点的前提下，减少系统调用</strong></li>
</ul>
<h3 id="select-poll-IO多路复用"><a href="#select-poll-IO多路复用" class="headerlink" title="select/poll IO多路复用"></a>select/poll IO多路复用</h3><p>​    <strong>多路复用主要复用的是通过有限次的系统调用来实现管理多个网络连接。最简单来说，我目前有 10 个连接，我可以通过一次系统调用将这 10 个连接都丢给内核，让内核告诉我，哪些连接上面数据准备好了，然后我再去读取每个就绪的连接上的数据。因此，IO 多路复用，复用的是系统调用。通过有限次系统调用判断海量连接是否数据准备好了</strong></p>
<ul>
<li><p><strong>select</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// readfds:关心读的fd集合；writefds：关心写的fd集合；excepttfds：异常的fd集合</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span> <span class="params">(<span class="keyword">int</span> n, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout)</span></span>;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<blockquote>
<p>select 函数监视的文件描述符分 3 类，分别是 writefds、readfds、和 exceptfds。调用后 select 函数会阻塞，直到有描述副就绪（有数据 可读、可写、或者有 except），或者超时（timeout 指定等待时间，如果立即返回设为 null 即可），函数返回。当 select 函数返回后，可以 通过遍历 fdset，来找到就绪的描述符。</p>
</blockquote>
<blockquote>
<p>select 目前几乎在所有的平台上支持，其良好跨平台支持也是它的一个优点。select 的一 个缺点在于单个进程能够监视的文件描述符的数量存在最大限制，在 Linux 上一般为 1024，可以通过修改宏定义甚至重新编译内核的方式提升这一限制，但 是这样也会造成效率的降低。</p>
</blockquote>
<ul>
<li><p><strong>poll</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll</span> <span class="params">(struct pollfd *fds, <span class="keyword">unsigned</span> <span class="keyword">int</span> nfds, <span class="keyword">int</span> timeout)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> fd; <span class="comment">/* file descriptor */</span></span><br><span class="line">    <span class="keyword">short</span> events; <span class="comment">/* requested events to watch */</span></span><br><span class="line">    <span class="keyword">short</span> revents; <span class="comment">/* returned events witnessed */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<blockquote>
<p>pollfd 结构包含了要监视的 event 和发生的 event，不再使用 select“参数-值”传递的方式。同时，pollfd 并没有最大数量限制（但是数量过大后性能也是会下降）。 和 select 函数一样，poll 返回后，需要轮询 pollfd 来获取就绪的描述符。</p>
<p>从上面看，select 和 poll 都需要在返回后，通过遍历文件描述符来获取已经就绪的 socket。事实上，同时连接的大量客户端在一时刻可能只有很少的处于就绪状态，因此随着监视的描述符数量的增长，其效率也会线性下降。</p>
</blockquote>
<ul>
<li><strong>从本质来说：IO 多路复用中，select()/poll()/epoll_wait()这几个函数对应第一阶段；read()/recvfrom()对应第二阶段</strong></li>
</ul>
<p><img src="/2021/03/15/%E7%BD%91%E7%BB%9CIO/5.jpg" alt="IO多路复用"></p>
<h4 id="select-poll-IO多路复用的优点"><a href="#select-poll-IO多路复用的优点" class="headerlink" title="select/poll IO多路复用的优点"></a>select/poll IO多路复用的优点</h4><p>​    <strong>IO 多路复用，主要在于复用，通过 select()或者 poll()将多个 socket fds 批量通过系统调用传递给内核，由内核进行循环遍历判断哪些 fd 上数据就绪了，然后将就绪的 readyfds 返回给用户。再由用户进行挨个遍历就绪好的 fd，读取或者写入数据。</strong></p>
<p>​    <strong>所以通过 IO 多路复用+非阻塞 IO，一方面降低了系统调用次数，另一方面可以用极少的线程来处理多个网络连接。</strong></p>
<h4 id="select-poll-IO多路复用的缺点"><a href="#select-poll-IO多路复用的缺点" class="headerlink" title="select/poll IO多路复用的缺点"></a>select/poll IO多路复用的缺点</h4><p>​    <strong>用户需要每次将海量的 socket fds 集合从用户态传递到内核态，让内核态去检测哪些网络连接数据就绪了</strong></p>
<p>​    <strong>但这个地方会出现频繁的将海量 fd 集合从用户态传递到内核态，再从内核态拷贝到用户态。 所以，这个地方开销也挺大。</strong></p>
<h4 id="select-poll-的区别"><a href="#select-poll-的区别" class="headerlink" title="select poll 的区别"></a>select poll 的区别</h4><ol>
<li>select 能处理的最大连接，默认是 1024 个，可以通过修改配置来改变，但终究是有限个；而 poll 理论上可以支持无限个</li>
<li>select 和 poll 在管理海量的连接时，会频繁的从用户态拷贝到内核态，比较消耗资源。</li>
</ol>
<h3 id="epoll-IO多路复用"><a href="#epoll-IO多路复用" class="headerlink" title="epoll IO多路复用"></a>epoll IO多路复用</h3><ul>
<li><strong>epoll</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建epollFd，底层是在内核态分配一段区域，底层数据结构红黑树+双向链表</span></span><br><span class="line">int epoll_create(int size)；//创建一个epoll的句柄，size用来告诉内核这个监听的数目一共有多大</span><br><span class="line"></span><br><span class="line"><span class="comment">//往红黑树中增加、删除、更新管理的socket fd</span></span><br><span class="line">int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)；</span><br><span class="line"></span><br><span class="line"><span class="comment">//这个api是用来在第一阶段阻塞，等待就绪的fd。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd, struct epoll_event * events, <span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> <span class="function"><span class="keyword">int</span> <span class="title">epoll_create</span><span class="params">(<span class="keyword">int</span> size)</span></span>;</span><br><span class="line">创建一个epoll的句柄，size用来告诉内核这个监听的数目一共有多大，这个参数不同于select()中的第一个参数，给出最大监听的fd+<span class="number">1</span>的值，参数size并不是限制了epoll所能监听的描述符最大个数，只是对内核初始分配内部数据结构的一个建议。</span><br><span class="line">当创建好epoll句柄后，它就会占用一个fd值，在linux下如果查看/proc/进程id/fd/，是能够看到这个fd的，所以在使用完epoll后，必须调用close()关闭，否则可能导致fd被耗尽。</span><br><span class="line"></span><br><span class="line">2. int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)；</span><br><span class="line">函数是对指定描述符fd执行op操作。</span><br><span class="line">- epfd：是epoll_create()的返回值。</span><br><span class="line">- op：表示op操作，用三个宏来表示：添加EPOLL_CTL_ADD，删除EPOLL_CTL_DEL，修改EPOLL_CTL_MOD。分别添加、删除和修改对fd的监听事件。</span><br><span class="line">- fd：是需要监听的fd（文件描述符）</span><br><span class="line">- epoll_event：是告诉内核需要监听什么事，<span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span>结构如下：</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> &#123;</span></span><br><span class="line">  <span class="keyword">__uint32_t</span> events;  <span class="comment">/* Epoll events */</span></span><br><span class="line">  <span class="keyword">epoll_data_t</span> data;  <span class="comment">/* User data variable */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//events可以是以下几个宏的集合：</span></span><br><span class="line">EPOLLIN ：表示对应的文件描述符可以读（包括对端SOCKET正常关闭）；</span><br><span class="line">EPOLLOUT：表示对应的文件描述符可以写；</span><br><span class="line">EPOLLPRI：表示对应的文件描述符有紧急的数据可读（这里应该表示有带外数据到来）；</span><br><span class="line">EPOLLERR：表示对应的文件描述符发生错误；</span><br><span class="line">EPOLLHUP：表示对应的文件描述符被挂断；</span><br><span class="line">EPOLLET： 将EPOLL设为边缘触发(Edge Triggered)模式，这是相对于水平触发(Level Triggered)来说的。</span><br><span class="line">EPOLLONESHOT：只监听一次事件，当监听完这次事件之后，如果还需要继续监听这个socket的话，需要再次把这个socket加入到EPOLL队列里</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> <span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd, struct epoll_event * events, <span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout)</span></span>;</span><br><span class="line">等待epfd上的io事件，最多返回maxevents个事件。</span><br><span class="line">参数events用来从内核得到事件的集合，maxevents告之内核这个events有多大，这个maxevents的值不能大于创建epoll_create()时的size，参数timeout是超时时间（毫秒，<span class="number">0</span>会立即返回，<span class="number">-1</span>将不确定，也有说法说是永久阻塞）。该函数返回需要处理的事件数目，如返回<span class="number">0</span>表示已超时。</span><br></pre></td></tr></table></figure>



<h4 id="epoll-工作模式"><a href="#epoll-工作模式" class="headerlink" title="epoll 工作模式"></a>epoll 工作模式</h4><ul>
<li>epoll 对文件描述符的操作有两种模式：LT（level trigger）和 ET（edge trigger）</li>
<li>LT 模式：当 epoll_wait 检测到描述符事件发生并将此事件通知应用程序，应用程序可以不立即处理该事件。下次调用 epoll_wait 时，会再次响应应用程序并通知此事件。 </li>
<li>ET 模式：当 epoll_wait 检测到描述符事件发生并将此事件通知应用程序，应用程序必须立即处理该事件。如果不处理，下次调用 epoll_wait 时，不会再次响应应用程序并通知此事件。</li>
</ul>
<ol>
<li><p>LT 模式</p>
<p>​    LT(level triggered)是缺省的工作方式，并且同时支持 block 和 no-block socket.在这种做法中，内核告诉你一个文件描述符是否就绪了，然后你可以对这个就绪的 fd 进行 IO 操作。如果你不作任何操作，内核还是会继续通知你的。</p>
</li>
<li><p>ET 模式</p>
<p>​    ET(edge-triggered)是高速工作方式，只支持 no-block socket。在这种模式下，当描述符从未就绪变为就绪时，内核通过 epoll 告诉你。然后它会假设你知道文件描述符已经就绪，并且不会再为那个文件描述符发送更多的就绪通知，直到你做了某些操作导致那个文件描述符不再为就绪状态了(比如，你在发送，接收或者接收请求，或者发送接收的数据少于一定量时导致了一个 EWOULDBLOCK 错误）。但是请注意，如果一直不对这个 fd 作 IO 操作(从而导致它再次变成未就绪)，内核不会发送更多的通知(only once)</p>
<p>​    ET 模式在很大程度上减少了 epoll 事件被重复触发的次数，因此效率要比 LT 模式高。epoll 工作在 ET 模式的时候，必须使用非阻塞套接口，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。</p>
</li>
<li><p>当 epoll_wait()调用后会阻塞，然后完了当返回时，会返回了哪些 fd 的数据就绪了，用户只需要遍历就绪的 fd 进行读写即可。</p>
</li>
</ol>
<h4 id="epoll多路复用优点"><a href="#epoll多路复用优点" class="headerlink" title="epoll多路复用优点"></a>epoll多路复用优点</h4><p>​    一开始就在内核态分配了一段空间，来存放管理的 fd,所以在每次连接建立后，交给 epoll 管理时，需要将其添加到原先分配的空间中，后面再管理时就不需要频繁的从用户态拷贝管理的 fd 集合。通通过这种方式大大的提升了性能。</p>
<p>​    所以现在的 IO 多路复用主要指 epoll</p>
<h3 id="异步-IO"><a href="#异步-IO" class="headerlink" title="异步 IO"></a><strong>异步 IO</strong></h3><p><img src="/2021/03/15/%E7%BD%91%E7%BB%9CIO/6.jpg" alt="异步IO"></p>
<p>​    异步 IO 指：<strong>内核态拷贝数据到用户态这种方式也是交给系统线程来实现，不由用户线程完成</strong>，目前只有 windows 系统的 IOCP 是属于异步 IO。</p>
<h3 id="网络IO模型"><a href="#网络IO模型" class="headerlink" title="网络IO模型"></a>网络IO模型</h3><h4 id="reactor模型"><a href="#reactor模型" class="headerlink" title="reactor模型"></a>reactor模型</h4><p><strong>1. 单 reactor 单线程模型</strong></p>
<p>此种模型，通常是只有一个 epoll 对象，所有的<strong>接收客户端连接</strong>、<strong>客户端读取</strong>、<strong>客户端写入</strong>操作都包含在一个线程内。该种模型也有一些中间件在用，比如 redis.</p>
<p><img src="/2021/03/15/%E7%BD%91%E7%BB%9CIO/7.jpg" alt="单reactor单线程模型"></p>
<blockquote>
<p>但在目前的单线程 Reactor 模式中，不仅 I/O 操作在该 Reactor 线程上，连非 I/O 的业务操作也在该线程上进行处理了，这可能会大大延迟 I/O 请求的响应。所以我们应该将非 I/O 的业务逻辑操作从 Reactor 线程上卸载，以此来加速 Reactor 线程对 I/O 请求的响应。</p>
</blockquote>
<p><strong>2. 单 reactor 多线程模型</strong></p>
<p>该模型主要是通过将，前面的模型进行改造，将读写的业务逻辑交给具体的线程池来实现，这样可以显示 reactor 线程对 IO 的响应，以此提升系统性能。</p>
<p><img src="/2021/03/15/%E7%BD%91%E7%BB%9CIO/8.jpg" alt="单reactor多线程模型"></p>
<blockquote>
<p>在工作者线程池模式中，虽然非 I/O 操作交给了线程池来处理，但是所有的 I/O 操作依然由 Reactor 单线程执行，在高负载、高并发或大数据量的应用场景，依然较容易成为瓶颈。所以，对于 Reactor 的优化，又产生出下面的多线程模式。</p>
</blockquote>
<p><strong>3. multi-reactor 多线程模型</strong></p>
<p>在这种模型中，主要分为两个部分：mainReactor、subReactors。 mainReactor 主要负责接收客户端的连接，然后将建立的客户端连接通过负载均衡的方式分发给 subReactors，</p>
<p>subReactors 来负责具体的每个连接的读写</p>
<p>对于非 IO 的操作，依然交给工作线程池去做，对逻辑进行解耦</p>
<p><img src="/2021/03/15/%E7%BD%91%E7%BB%9CIO/9.jpg" alt="单reactor多线程模型"></p>
<blockquote>
<p>mainReactor 对应 Netty 中配置的 BossGroup 线程组，主要负责接受客户端连接的建立。一般只暴露一个服务端口，BossGroup 线程组一般一个线程工作即可 subReactor 对应 Netty 中配置的 WorkerGroup 线程组，BossGroup 线程组接受并建立完客户端的连接后，将网络 socket 转交给 WorkerGroup 线程组，然后在 WorkerGroup 线程组内选择一个线程，进行 I/O 的处理。WorkerGroup 线程组主要处理 I/O，一般设置 2*CPU 核数个线程</p>
</blockquote>
<p><strong>4. multi-reactor 多进程模型</strong></p>
<h4 id="Proactor模式"><a href="#Proactor模式" class="headerlink" title="Proactor模式"></a>Proactor模式</h4><p>​    流程与Reactor模式类似，区别在于proactor在IO ready事件触发后，完成IO操作再通知应用回调。虽然在linux平台还是基于epoll/select，但是内部实现了异步操作处理器(Asynchronous Operation Processor)以及异步事件分离器(Asynchronous Event Demultiplexer)将IO操作与应用回调隔离。经典应用例如boost asio异步IO库的结构和流程图如下：</p>
<p><img src="/2021/03/15/%E7%BD%91%E7%BB%9CIO/10.jpg" alt="Proactor模型"></p>
<p><img src="/2021/03/15/%E7%BD%91%E7%BB%9CIO/11.jpg" alt="Proactor模型"></p>
<p>Reactor模式中，用户线程通过向Reactor对象注册感兴趣的事件监听，然后事件触发时调用事件处理函数。而Proactor模式中，用户线程将AsynchronousOperation（读/写等）、Proactor以及操作完成时的CompletionHandler注册到AsynchronousOperationProcessor。</p>
<p>AsynchronousOperationProcessor使用Facade模式提供了一组异步操作API（读/写等）供用户使用，当用户线程调用异步API后，便继续执行自己的任务。AsynchronousOperationProcessor 会开启独立的内核线程执行异步操作，实现真正的异步。当异步IO操作完成时，AsynchronousOperationProcessor将用户线程与AsynchronousOperation一起注册的Proactor和CompletionHandler取出，然后将CompletionHandler与IO操作的结果数据一起转发给Proactor，Proactor负责回调每一个异步操作的事件完成处理函数handle_event。虽然Proactor模式中每个异步操作都可以绑定一个Proactor对象，但是一般在操作系统中，Proactor被实现为Singleton模式，以便于集中化分发操作完成事件。</p>
<p><img src="/2021/03/15/%E7%BD%91%E7%BB%9CIO/12.jpg" alt="Proactor模型"></p>
<h4 id="Reactor模式和Proactor模式的总结对比"><a href="#Reactor模式和Proactor模式的总结对比" class="headerlink" title="Reactor模式和Proactor模式的总结对比"></a>Reactor模式和Proactor模式的总结对比</h4><ul>
<li><p>主动和被动： </p>
<ul>
<li><p>Reactor将handler放到select()，等待可写就绪，然后调用write()写入数据；写完数据后再处理后续逻辑；</p>
</li>
<li><p>Proactor调用aoi_write后立刻返回，由内核负责写操作，写完后调用相应的回调函数处理后续逻辑</p>
</li>
<li><p><strong>Reactor模式是一种被动的处理</strong>，即有事件发生时被动处理。而<strong>Proator模式则是主动发起异步调用</strong>，然后循环检测完成事件。</p>
</li>
</ul>
</li>
<li><p>实现</p>
<ul>
<li>Reactor实现了一个被动的事件分离和分发模型，服务等待请求事件的到来，再通过不受间断的同步处理事件，从而做出反应；</li>
<li>Proactor实现了一个主动的事件分离和分发模型；这种设计允许多个任务并发的执行，从而提高吞吐量。</li>
<li>所以涉及到文件I/O或耗时I/O可以使用Proactor模式，或使用多线程模拟实现异步I/O的方式。</li>
</ul>
</li>
<li><p>优点：</p>
<ul>
<li>Reactor实现相对简单，对于链接多，但耗时短的处理场景高效；</li>
<li>操作系统可以在多个事件源上等待，并且避免了线程切换的性能开销和编程复杂性；</li>
<li>事件的串行化对应用是透明的，可以顺序的同步执行而不需要加锁；</li>
<li>事务分离：将与应用无关的多路复用、分配机制和与应用相关的回调函数分离开来。</li>
</ul>
</li>
<li><p>缺点：</p>
<ul>
<li>Reactor处理耗时长的操作会造成事件分发的阻塞，影响到后续事件的处理；</li>
<li>Proactor实现逻辑复杂；依赖操作系统对异步的支持，目前实现了纯异步操作的操作系统少，实现优秀的如windows IOCP，但由于其windows系统用于服务器的局限性，目前应用范围较小；而Unix/Linux系统对纯异步的支持有限，应用事件驱动的主流还是通过select/epoll来实现。</li>
</ul>
</li>
<li><p>使用场景：</p>
<ul>
<li>Reactor：同时接收多个服务请求，并且依次同步的处理它们的事件驱动程序；</li>
<li>Proactor：异步接收和同时处理多个服务请求的事件驱动程序。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>C++ 网络编程</category>
      </categories>
      <tags>
        <tag>C++ 网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Http和Https网络协议</title>
    <url>/2021/03/16/Http%E5%92%8CHttps%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<h3 id="HTTP和HTTPS发展历史"><a href="#HTTP和HTTPS发展历史" class="headerlink" title="HTTP和HTTPS发展历史"></a>HTTP和HTTPS发展历史</h3><h4 id="什么是HTTP"><a href="#什么是HTTP" class="headerlink" title="什么是HTTP?"></a>什么是HTTP?</h4><blockquote>
<p>超文本传输协议（英语：<strong>H</strong>yper<strong>T</strong>ext <strong>T</strong>ransfer <strong>P</strong>rotocol，缩写：<strong>HTTP</strong>），是一个基于请求与响应，无状态的，应用层的协议，常基于TCP/IP协议传输数据，互联网上应用最为广泛的一种网络协议,所有的WWW文件都必须遵守这个标准。设计HTTP的初衷是为了提供一种发布和接收HTML页面的方法。</p>
</blockquote>
<a id="more"></a>

<ul>
<li>发展历史：</li>
</ul>
<table>
<thead>
<tr>
<th align="left">版本</th>
<th align="center"><strong>产生时间</strong></th>
<th align="center"><strong>内容</strong></th>
<th align="center"><strong>发展现状</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left">HTTP/0.9</td>
<td align="center">1991年</td>
<td align="center">不涉及数据包传输，规定客户端和服务器之间通信格式，只能GET请求</td>
<td align="center">没有作为正式的标准</td>
</tr>
<tr>
<td align="left">HTTP/1.0</td>
<td align="center">1996年</td>
<td align="center">传输内容格式不限制，增加PUT、PATCH、HEAD、 OPTIONS、DELETE命令</td>
<td align="center">正式作为标准</td>
</tr>
<tr>
<td align="left">HTTP/1.1</td>
<td align="center">1997年</td>
<td align="center">持久连接(长连接)、节约带宽、HOST域、管道机制、分块传输编码</td>
<td align="center">2015年前使用最广泛</td>
</tr>
<tr>
<td align="left">HTTP/2.0</td>
<td align="center">2015年</td>
<td align="center">多路复用、服务器推送、头信息压缩、二进制协议等</td>
<td align="center">逐渐覆盖市场</td>
</tr>
</tbody></table>
<p><img src="/2021/03/16/Http%E5%92%8CHttps%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/0.png"></p>
<p>使用HTTP/1.1和HTTP/2同时请求379张图片，观察请求的时间，明显看出<strong>HTTP/2性能占优势</strong>。</p>
<p><img src="/2021/03/16/Http%E5%92%8CHttps%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/1.jfif"></p>
<p><strong>多路复用</strong>：通过单一的HTTP/2连接请求发起多重的请求-响应消息，多个请求stream共享一个TCP连接，实现多留并行而不是依赖建立多个TCP连接。</p>
<h4 id="HTTP报文格式"><a href="#HTTP报文格式" class="headerlink" title="HTTP报文格式"></a>HTTP报文格式</h4><p><img src="/2021/03/16/Http%E5%92%8CHttps%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/1.png" alt="http报文格式"></p>
<p>一个HTTP请求报文由<strong>请求行（request line）、请求头部（header）、空行和请求数据</strong>4个部分组成</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">＜request-line＞</span><br><span class="line"></span><br><span class="line">＜headers＞</span><br><span class="line"></span><br><span class="line">＜blank line＞</span><br><span class="line"></span><br><span class="line">[＜request-body＞]</span><br></pre></td></tr></table></figure>

<p>HTTP响应也由三个部分组成，分别是：<strong>状态行、消息报头、响应正文</strong>。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">＜status-line＞</span><br><span class="line"></span><br><span class="line">＜headers＞</span><br><span class="line"></span><br><span class="line">＜blank line＞</span><br><span class="line"></span><br><span class="line">[＜response-body＞]</span><br></pre></td></tr></table></figure>

<h5 id="常见状态码"><a href="#常见状态码" class="headerlink" title="常见状态码"></a>常见状态码</h5><p>常见状态代码、状态描述的说明如下。</p>
<ul>
<li><p>200 OK：客户端请求成功。</p>
</li>
<li><p>400 Bad Request：客户端请求有语法错误，不能被服务器所理解。</p>
</li>
<li><p>401 Unauthorized：请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用。</p>
</li>
<li><p>403 Forbidden：服务器收到请求，但是拒绝提供服务。</p>
</li>
<li><p>404 Not Found：请求资源不存在，举个例子：输入了错误的URL。</p>
</li>
<li><p>500 Internal Server Error：服务器发生不可预期的错误。</p>
</li>
<li><p>503 Server Unavailable：服务器当前不能处理客户端的请求，一段时间后可能恢复正常，举个例子：HTTP/1.1 200 OK（CRLF）。</p>
</li>
<li><p>1xx：指示信息–表示请求已接收，继续处理。</p>
</li>
<li><p>2xx：成功–表示请求已被成功接收、理解、接受。</p>
</li>
<li><p>3xx：重定向–要完成请求必须进行更进一步的操作。</p>
</li>
<li><p>4xx：客户端错误–请求有语法错误或请求无法实现。</p>
</li>
<li><p>5xx：服务器端错误–服务器未能实现合法的请求。</p>
</li>
</ul>
<h4 id="什么是HTTPS"><a href="#什么是HTTPS" class="headerlink" title="什么是HTTPS?"></a>什么是HTTPS?</h4><blockquote>
<p>HTTPS是一种通过计算机网络进行安全通信的传输协议，经由HTTP进行通信，利用<strong>SSL/TLS</strong>建立全信道，加密数据包。HTTPS使用的主要目的是提供对网站服务器的<strong>身份认证</strong>，同时<strong>保护交换数据的隐私</strong>与<strong>完整性</strong>。</p>
<blockquote>
<p>PS:TLS是传输层加密协议，前身是SSL协议，由网景公司1995年发布，有时候两者不区分。</p>
</blockquote>
</blockquote>
<h3 id="HTTP-VS-HTTPS"><a href="#HTTP-VS-HTTPS" class="headerlink" title="HTTP VS HTTPS"></a>HTTP VS HTTPS</h3><p><strong>HTTP特点：</strong></p>
<ul>
<li>无状态：协议对客户端没有状态存储，对事物处理没有“记忆”能力，比如访问一个网站需要反复进行登录操作</li>
<li>无连接：HTTP/1.1之前，由于无状态特点，每次请求需要通过TCP三次握手四次挥手，和服务器重新建立连接。比如某个客户机在短时间多次请求同一个资源，服务器并不能区别是否已经响应过用户的请求，所以每次需要重新响应请求，需要耗费不必要的时间和流量。</li>
<li>基于请求和响应：基本的特性，由客户端发起请求，服务端响应</li>
<li>简单快速、灵活</li>
<li>通信使用明文、请求和响应不会对通信方进行确认、无法保护数据的完整性</li>
</ul>
<p><strong>针对无状态的一些解决策略：</strong><br><strong>场景：逛电商商场用户需要使用的时间比较长，需要对用户一段时间的HTTP通信状态进行保存，比如执行一次登陆操作，在30分钟内所有的请求都不需要再次登陆。</strong></p>
<ol>
<li>通过Cookie/Session技术</li>
<li>HTTP/1.1持久连接（HTTP keep-alive）方法，只要任意一端没有明确提出断开连接，则保持TCP连接状态，在请求首部字段中的Connection: keep-alive即为表明使用了持久连接</li>
</ol>
<p><strong>HTTPS特点：</strong></p>
<ul>
<li>基于HTTP协议，通过SSL或TLS提供加密处理数据、验证对方身份以及数据完整性保护<ul>
<li>内容加密：采用混合加密技术，中间者无法直接查看明文内容</li>
<li>验证身份：通过证书认证客户端访问的是自己的服务器</li>
<li>保护数据完整性：防止传输的内容被中间人冒充或者篡改</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>混合加密：</strong>结合非对称加密和对称加密技术。客户端使用对称加密生成密钥对传输数据进行加密，然后使用非对称加密的公钥再对秘钥进行加密，所以网络上传输的数据是被秘钥加密的密文和用公钥加密后的秘密秘钥，因此即使被黑客截取，由于没有私钥，无法获取到加密明文的秘钥，便无法获取到明文数据。</p>
<p>.<strong>数字摘要：</strong>通过单向hash函数对原文进行哈希，将需加密的明文“摘要”成一串固定长度(如128bit)的密文，不同的明文摘要成的密文其结果总是不相同，同样的明文其摘要必定一致，并且即使知道了摘要也不能反推出明文。</p>
<p><strong>数字签名技术：</strong>数字签名建立在公钥加密体制基础上，是公钥加密技术的另一类应用。它把公钥加密技术和数字摘要结合起来，形成了实用的数字签名技术。</p>
</blockquote>
<ul>
<li>收方能够证实发送方的真实身份；</li>
<li>发送方事后不能否认所发送过的报文；</li>
<li>收方或非法者不能伪造、篡改报文。</li>
</ul>
<p><img src="/2021/03/16/Http%E5%92%8CHttps%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/2.png" alt="https加密过程"></p>
<p>非对称加密过程需要用到公钥进行加密，那么公钥从何而来？其实公钥就被包含在数字证书中，数字证书通常来说是由受信任的数字证书颁发机构CA，在验证服务器身份后颁发，证书中包含了一个密钥对（公钥和私钥）和所有者识别信息。数字证书被放到服务端，具有服务器身份验证和数据传输加密功能。</p>
<h3 id="HTTP通信传输"><a href="#HTTP通信传输" class="headerlink" title="HTTP通信传输"></a>HTTP通信传输</h3><p><img src="/2021/03/16/Http%E5%92%8CHttps%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/2.jfif"></p>
<p>客户端输入URL回车，DNS解析域名得到服务器的IP地址，服务器在80端口监听客户端请求，端口通过TCP/IP协议（可以通过Socket实现）建立连接。HTTP属于TCP/IP模型中的应用层协议。</p>
<p><img src="/2021/03/16/Http%E5%92%8CHttps%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/3.jfif"></p>
<p>报文从应用层传送到运输层，运输层通过TCP三次握手和服务器建立连接，四次挥手释放连接。</p>
<p><img src="/2021/03/16/Http%E5%92%8CHttps%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/3.png" alt="tcp传输层三次握手"></p>
<p><img src="/2021/03/16/Http%E5%92%8CHttps%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/9.png" alt="tcp传输层三次握手"></p>
<p><strong>Q1: 为什么需要三次握手呢？为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。</strong></p>
<ul>
<li>比如：client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。本来这是一个早已失效的报文段，但是server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求，于是就向client发出确认报文段，同意建立连接。假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了，由于client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据，但server却以为新的运输连接已经建立，并一直等待client发来数据。所以没有采用“三次握手”，这种情况下server的很多资源就白白浪费掉了。</li>
</ul>
<p><img src="/2021/03/16/Http%E5%92%8CHttps%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/4.png" alt="tcp传输层四次挥手"></p>
<p><img src="/2021/03/16/Http%E5%92%8CHttps%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/5.png" alt="tcp传输层四次挥手"></p>
<p><strong>Q2：为什么需要四次挥手呢？</strong></p>
<ul>
<li>TCP是全双工模式，当client发出FIN报文段时，只是表示client已经没有数据要发送了，client告诉server，它的数据已经全部发送完毕了；但是，这个时候client还是可以接受来server的数据；当server返回ACK报文段时，表示它已经知道client没有数据发送了，但是server还是可以发送数据到client的；</li>
<li>当server也发送了FIN报文段时，这个时候就表示server也没有数据要发送了，就会告诉client，我也没有数据要发送了，如果收到client确认报文段，之后彼此就会愉快的中断这次TCP连接。</li>
</ul>
<p><strong>Q3：当客户端进入TIME-WAIT状态的时候(也就是第四次挥手的时候)，必须经过时间计数器设置的时间2MSL(最长报文段寿命)后，才能进入关闭状态，这时为什么呢？</strong></p>
<ul>
<li><p><strong>为了保证客户端发送的最后一个ACK报文段能够到达服务器</strong>。因为这个ACK有可能丢失，从而导致处在LAST-ACK状态的服务器收不到对FIN-ACK的确认报文。服务器会超时重传这个FIN-ACK，接着客户端再重传一次确认，重新启动时间等待计时器。最后客户端和服务器都能正常的关闭。假设客户端不等待2MSL，而是在发送完ACK之后直接释放关闭，一但这个ACK丢失的话，服务器就无法正常的进入关闭连接状态。</p>
</li>
<li><p><strong>还可以防止已失效的报文段</strong>。客户端在发送最后一个ACK之后，再经过经过2MSL，就可以使本链接持续时间内所产生的所有报文段都从网络中消失。从保证在关闭连接后不会有还在网络中滞留的报文段去骚扰服务器。</p>
</li>
</ul>
<p>注意：在服务器发送了FIN-ACK之后，会立即启动超时重传计时器。客户端在发送最后一个ACK之后会立即启动时间等待计时器。</p>
<h3 id="HTTPS实现原理"><a href="#HTTPS实现原理" class="headerlink" title="HTTPS实现原理"></a>HTTPS实现原理</h3><blockquote>
<p>https = http + tls / ssl</p>
</blockquote>
<p><img src="/2021/03/16/Http%E5%92%8CHttps%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/9" alt="https握手过程"></p>
<p><strong>SSL建立连接过程</strong></p>
<ul>
<li>在通信双方建立可靠的 TCP 连接之后，我们就需要通过 TLS 握手交换双方的密钥了</li>
</ul>
<p><img src="/2021/03/16/Http%E5%92%8CHttps%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/10.png" alt="https握手过程"></p>
<ol>
<li>客户端向服务端发送 Client Hello 消息，其中携带客户端支持的协议版本、加密算法、压缩算法以及<strong>客户端生成的随机数</strong>；</li>
<li>服务端收到客户端支持的协议版本、加密算法等信息后；<ol>
<li>向客户端发送 Server Hello 消息，并携带选择特定的协议版本、加密方法、会话 ID 以及<strong>服务端生成的随机数</strong>；</li>
<li>向客户端发送 Certificate 消息，即服务端的证书链，其中包含证书支持的域名、发行方和有效期等信息；</li>
<li>向客户端发送 Server Key Exchange 消息，传递<strong>公钥</strong>以及签名等信息；</li>
<li>向客户端发送可选的消息 CertificateRequest，验证客户端的证书；</li>
<li>向客户端发送 Server Hello Done 消息，通知服务端已经发送了全部的相关信息；</li>
</ol>
</li>
<li>客户端收到服务端的协议版本、加密方法、会话 ID 以及证书等信息后，验证服务端的证书；<ol>
<li>向服务端发送 Client Key Exchange 消息，包含<strong>使用服务端公钥加密后的随机字符串</strong>，即预主密钥（Pre Master Secret）；</li>
<li>向服务端发送 Change Cipher Spec 消息，通知服务端后面的数据段会加密传输；</li>
<li>向服务端发送 Finished 消息，其中包含加密后的握手信息；</li>
</ol>
</li>
<li>服务端收到 Change Cipher Spec 和 Finished 消息后；<ol>
<li>向客户端发送 Change Cipher Spec 消息，通知客户端后面的数据段会加密传输；</li>
<li>向客户端发送 Finished 消息，验证客户端的 Finished 消息并完成 TLS 握手；</li>
</ol>
</li>
</ol>
<p>TLS 握手的关键在于利用通信双方生成的随机字符串和服务端的公钥生成一个双方经过协商后的密钥，通信的双方可以使用这个对称的密钥加密消息防止中间人的监听和攻击，保证通信的安全。</p>
<p><img src="/2021/03/16/Http%E5%92%8CHttps%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/6.png" alt="https握手过程"></p>
<ol>
<li>client向server发送请求<a href="https://baidu.com,然后连接到server的**443**端口,发送的信息主要是**随机值1**和**客户端支持的加密算法**./">https://baidu.com，然后连接到server的**443**端口，发送的信息主要是**随机值1**和**客户端支持的加密算法**。</a></li>
<li>server接收到信息之后给予client响应握手信息，包括<strong>随机值2</strong>和<strong>匹配好的协商加密算法</strong>，这个加密算法一定是client发送给server加密算法的子集。</li>
<li>随即server给client发送<strong>第二个响应报文是数字证书</strong>。服务端必须要有一套数字证书，可以自己制作，也可以向组织申请。区别就是自己颁发的证书需要客户端验证通过，才可以继续访问，而使用受信任的公司申请的证书则不会弹出提示页面，这套证书其实就是<strong>一对公钥和私钥</strong>。传送证书，<strong>这个证书其实就是公钥，只是包含了很多信息，如证书的颁发机构，过期时间、服务端的公钥，第三方证书认证机构(CA)的签名，服务端的域名信息等内容</strong>。</li>
<li>客户端解析证书，这部分工作是<strong>由客户端的TLS来完成的</strong>，首先会<strong>验证公钥是否有效，比如颁发机构，过期时间等等</strong>，如果发现异常，则会弹出一个警告框，提示证书存在问题。如果证书没有问题，那么就<strong>生成一个随即值（预主秘钥）</strong>。</li>
<li>客户端认证证书通过之后，接下来是通过<strong>随机值1、随机值2和预主秘钥组装会话秘钥</strong>。然后<strong>通过证书的公钥加密会话秘钥</strong>。</li>
<li>传送加密信息，这部分传送的是用证书加密后的会话秘钥，目的就是<strong>让服务端使用秘钥解密得到随机值1、随机值2和预主秘钥</strong>。</li>
<li>服务端解密得到随机值1、随机值2和预主秘钥，然后组装会话秘钥，跟客户端会话秘钥相同。</li>
<li>客户端通过会话秘钥加密一条消息发送给服务端，主要验证服务端是否正常接受客户端加密的消息。</li>
<li>同样服务端也会通过会话秘钥加密一条消息回传给客户端，如果客户端能够正常接受的话表明SSL层连接建立完成了。</li>
</ol>
<p><strong>Q4：怎么保证保证服务器给客户端下发的公钥是真正的公钥，而不是中间人伪造的公钥呢？</strong></p>
<ul>
<li><p><img src="/2021/03/16/Http%E5%92%8CHttps%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/7.png" alt="https握手过程"></p>
</li>
<li></li>
</ul>
<p><img src="/2021/03/16/Http%E5%92%8CHttps%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/8.png" alt="https握手过程"></p>
<ul>
<li><strong>数字证书内容</strong><ul>
<li>包括了加密后服务器的公钥、权威机构的信息、服务器域名，还有经过CA私钥签名之后的证书内容（经过先通过Hash函数计算得到证书数字摘要，然后用权威机构私钥加密数字摘要得到数字签名)，签名计算方法以及证书对应的域名</li>
</ul>
</li>
<li><strong>验证证书安全性过程</strong><ul>
<li>当客户端收到这个证书之后，使用本地配置的权威机构的公钥对证书进行解密得到服务端的公钥和证书的数字签名，数字签名经过CA公钥解密得到证书信息摘要。</li>
<li>然后用证书签名的方法计算一下当前证书的信息摘要，与收到的信息摘要作对比，如果一样，表示证书一定是服务器下发的，没有被中间人篡改过。因为中间人虽然有权威机构的公钥，能够解析证书内容并篡改，但是篡改完成之后中间人需要将证书重新加密，但是中间人没有权威机构的私钥，无法加密，强行加密只会导致客户端无法解密，如果中间人强行乱修改证书，就会导致证书内容和证书签名不匹配。</li>
</ul>
</li>
<li><strong>那第三方攻击者能否让自己的证书显示出来的信息也是服务端呢？</strong><ul>
<li>（伪装服务端一样的配置）显然这个是不行的，因为当第三方攻击者去CA那边寻求认证的时候CA会要求其提供例如域名的whois信息、域名管理邮箱等证明你是服务端域名的拥有者，而第三方攻击者是无法提供这些信息所以他就是无法骗CA他拥有属于服务端的域名。</li>
</ul>
</li>
</ul>
<p><strong>Q5：中间人有可能篡改证书吗？</strong></p>
<ul>
<li>假如中间人获取到了CA证书，并修改了证书中的域名，但是此时它没有CA机构的私钥，所以它无法得到一个新的签名，然后客户端收到该篡改的证书后，通过私钥解密出来一个原证书信息的摘要，并且客户端对收到的证书内容生成信息摘要，发现两个信息不一致，就会终止通信，防止信息泄露。</li>
</ul>
<p><strong>Q6：HTTPS必须在每次请求中都要先在SSL/TLS层进行握手传输密钥吗？</strong></p>
<ul>
<li>其实是通过一个Session Identifier（会话标识符），该Session ID是 TLS 握手中生成的 Session ID。服务端可以将 Session ID 协商后的信息存起来，浏览器也可以保存 Session ID，并在后续的 Client Hello 握手中带上它，如果服务端能找到与之匹配的信息，就可以完成一次快速握手。</li>
</ul>
<h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><ul>
<li>安全性考虑：<br>.<ul>
<li>HTTPS协议的加密范围也比较有限，在黑客攻击、拒绝服务攻击、服务器劫持等方面几乎起不到什么作用</li>
<li>SSL证书的信用链体系并不安全，特别是在某些国家可以控制CA根证书的情况下，中间人攻击一样可行</li>
</ul>
</li>
</ul>
<ul>
<li>成本考虑：<ul>
<li>SSL证书需要购买申请，功能越强大的证书费用越高</li>
<li>SSL证书通常需要绑定IP，不能在同一IP上绑定多个域名，IPv4资源不可能支撑这个消耗（SSL有扩展可以部分解决这个问题，但是比较麻烦，而且要求浏览器、操作系统支持，Windows XP就不支持这个扩展，考虑到XP的装机量，这个特性几乎没用）。</li>
<li>根据ACM CoNEXT数据显示，使用HTTPS协议会使页面的加载时间延长近50%，增加10%到20%的耗电。</li>
<li>HTTPS连接缓存不如HTTP高效，流量成本高。</li>
<li>HTTPS连接服务器端资源占用高很多，支持访客多的网站需要投入更大的成本。</li>
<li>HTTPS协议握手阶段比较费时，对网站的响应速度有影响，影响用户体验。比较好的方式是采用分而治之，类似12306网站的主页使用HTTP协议，有关于用户信息等方面使用HTTPS。</li>
</ul>
</li>
</ul>
<h4 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h4><p><a href="https://draveness.me/whys-the-design-https-latency/">为什么 HTTPS 需要 7 次握手以及 9 倍时延</a></p>
<p><a href="https://blog.csdn.net/xiaoming100001/article/details/81109617">HTTP和HTTPS协议，看一篇就够了</a></p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
</search>
